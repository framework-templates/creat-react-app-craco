import { Component } from 'react';
import { Button, Table } from 'antd';
import 'src/views/journal/components/journalTabel/index.scss';

class index extends Component {
  constructor(props) {
    super(props);
    this.state = {
      dataSource: [
        {
          id: 24,
          title: '一步一步告诉你element-ui按需插件的原理以及实现方式',
          section:
            '对于一些组件库的使用，想必大家伙都知道怎么去引入及使用，但我们常用的组件库对应的按需引入插件是做什么的呢？它的原理是什么？又是怎么实现的？这里我们来一步一步来对element-ui的按需插件做一个文章来了解这类插件的工作方式',
          editorText:
            '<h2><span style="color: rgb(161, 0, 0);">什么是按需引入</span></h2><p><br></p><p>顾名思义，就是你需要的，我就给你引入进去，实则是对你需要的组件进行打包，而只是那些你需要的组件进行打包</p><p><br></p><p>接下来我们看一入口代码</p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-keyword">import</span>&nbsp;Vue&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">"vue"</span>;\n<span class="hljs-keyword">import</span>&nbsp;{&nbsp;Button&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">"element-ui"</span>;\nVue.use(Button);\n<span class="hljs-keyword">new</span>&nbsp;Vue({\n&nbsp;&nbsp;el:&nbsp;<span class="hljs-string">"<span class="hljs-subst">#app</span>"</span>,\n});\n</pre><p><br></p><p>再看下webpack.config.js的配置</p><p><br></p><pre class="ql-syntax" spellcheck="false">module.exports&nbsp;=&nbsp;{\n<span class="hljs-symbol">&nbsp;&nbsp;mode:</span>&nbsp;<span class="hljs-string">"production"</span>,\n<span class="hljs-symbol">&nbsp;&nbsp;entry:</span>&nbsp;{\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;index:</span>&nbsp;<span class="hljs-string">"./src/index.js"</span>,\n&nbsp;&nbsp;},\n<span class="hljs-symbol">&nbsp;&nbsp;module:</span>&nbsp;{\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;rules:</span>&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test:</span>&nbsp;/\\.m?js$/,\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exclude:</span>&nbsp;/(node_modules)/,\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use:</span>&nbsp;{\n<span class="hljs-symbol">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader:</span>&nbsp;<span class="hljs-string">"babel-loader"</span>,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;],\n&nbsp;&nbsp;},\n};\n</pre><p><br></p><p>使用webpack打包看一下</p><p><br></p><p><img src="http://qiniu.wztqy.top/7df5df20-e3c5-11eb-b704-e35965abd983.png"></p><p><br></p><p>我们可以看到，打包出来的大小有755kb，这里element-ui占用了大量的体积</p><p><br></p><p>接下来我们来对比下使用按需引入后的体积</p><p><br></p><p><img src="http://qiniu.wztqy.top/067bd2a0-e3c6-11eb-b704-e35965abd983.png"></p><p><br></p><p>根据官当的提示安装 babel-plugin-component</p><p><br></p><pre class="ql-syntax" spellcheck="false">npm <span class="hljs-keyword">install babel-plugin-component </span>-D\n</pre><p><br></p><p><span style="color: rgb(94, 109, 130);">然后，将 .babelrc 修改为：</span></p><p><br></p><pre class="ql-syntax" spellcheck="false">{\n  ...,\n  <span class="hljs-string">"plugins"</span>: [\n    [\n      <span class="hljs-string">"component"</span>,\n      {\n        <span class="hljs-string">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>,\n        <span class="hljs-string">"style"</span><span class="hljs-symbol">:false</span>\n      }\n    ]\n  ]\n}\n</pre><p><br></p><p>再次打包看下结果</p><p><br></p><p><img src="http://qiniu.wztqy.top/ef4a3620-e3c6-11eb-b704-e35965abd983.png"></p><p><br></p><p>这次我们可以看到，打包体积明显减小了到67KB了</p><p><br></p><p>那 babel-plugin-component 它做了什么事情呢？这里我们可以来分析一下</p><p><br></p><p>这里我们先移除babel-plugin-component ，然后将我们将入口源码改成下方代码块，然后再试一下</p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-keyword">import</span>&nbsp;Vue&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">"vue"</span>;\n<span class="hljs-keyword">const</span>&nbsp;Button&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">"element-ui/lib/button.js"</span>);\nVue.use(Button);\n<span class="hljs-keyword">new</span>&nbsp;Vue({\n&nbsp;&nbsp;el:&nbsp;<span class="hljs-string">"<span class="hljs-subst">#app</span>"</span>,\n});\n</pre><p><br></p><p>再次打包试下</p><p><br></p><p><img src="http://qiniu.wztqy.top/c03ef2c0-e3c7-11eb-b704-e35965abd983.png"></p><p><br></p><p>当我看到这个结果后，我发现，其实这就是我们想要的结果</p><p><br></p><h2><span style="color: rgb(161, 0, 0);">babel-plugin-component 原理</span></h2><p><br></p><p>babel-plugin-component 其实就是帮我们把import那块的代码，换成了require的形式后，再去做的打包，这样子就达到了我们按需的效果了</p><p><br></p><p>对于代码的转换，我们第一时间就可以想到babel，babel的功能非常强大，他有着代码的ast解析、遍历、转换等等功能，在这里不得不说，babel-plugin-component其实就是靠着babel做的这些事情</p><p><br></p><p>那我们应该怎么去实现一个自己的babel-plugin-component，以打包按需的效果呢</p><p><br></p><h2><span style="color: rgb(161, 0, 0);">babel-plugin-component 的实现</span></h2><p><br></p><p>我们在根目录创建一个 myBabelPluginComponent.js</p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-regexp">//my</span>BabelPluginComponent.js必须导出一个函数，函数里边也必须return一个对象\nmodule.exports&nbsp;=&nbsp;<span class="hljs-keyword">function</span>&nbsp;({&nbsp;types&nbsp;})&nbsp;{\n&nbsp;&nbsp;let&nbsp;libraryName&nbsp;=&nbsp;<span class="hljs-string">""</span>;\n&nbsp;&nbsp;<span class="hljs-regexp">//</span>&nbsp;驼峰转横线\n&nbsp;&nbsp;<span class="hljs-keyword">function</span>&nbsp;umpHunderline(data)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.replace(<span class="hljs-regexp">/([A-Z])/g</span>,&nbsp;<span class="hljs-string">"-$1"</span>)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.toLowerCase()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.slice(<span class="hljs-number">1</span>);\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;<span class="hljs-regexp">//</span>创建require节点\n&nbsp;&nbsp;<span class="hljs-keyword">function</span>&nbsp;creatRequire(name)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;underlineName&nbsp;=&nbsp;umpHunderline(name);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;types.VariableDeclaration(<span class="hljs-string">"const"</span>,&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types.VariableDeclarator(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types.Identifier(name),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types.CallExpression(types.Identifier(<span class="hljs-string">"require"</span>),&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types.stringLiteral(`element-ui<span class="hljs-regexp">/lib/</span><span class="hljs-variable">${underlineName}</span>.js`),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),\n&nbsp;&nbsp;&nbsp;&nbsp;]);\n&nbsp;&nbsp;}\n\n   <span class="hljs-regexp">//</span> 导出一个对象\n&nbsp;&nbsp;return&nbsp;{\n       <span class="hljs-regexp">//</span> visitor为入口\n&nbsp;&nbsp;&nbsp;&nbsp;visitor:&nbsp;{\n           <span class="hljs-regexp">//</span> 跟节点对象,始终只执行一次\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Program(_,&nbsp;{&nbsp;opts&nbsp;})&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libraryName&nbsp;=&nbsp;opts.libraryName&nbsp;||&nbsp;<span class="hljs-string">"element-ui"</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n           <span class="hljs-regexp">//</span> 导入节点的对象，有多少个导入（import）即执行多少次\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImportDeclaration(path)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;{&nbsp;node&nbsp;}&nbsp;=&nbsp;path;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp">//</span>&nbsp;判断import导入的模块是否为element-ui的模块\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.source.value&nbsp;===&nbsp;libraryName)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp">//</span>替换&nbsp;import&nbsp;变成按需的&nbsp;require<span class="hljs-regexp">//</span> 由于可能需要替换成多个require导入code即：<span class="hljs-regexp">//</span> const Input = require(<span class="hljs-string">\'element-ui/lib/input.js\'</span>)﻿<span class="hljs-regexp">//</span> const Button = require(<span class="hljs-string">\'element-ui/lib/button.js\'</span>)﻿\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.replaceWithMultiple(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-regexp">//</span>&nbsp;获取定义的的组件名，转化node（const&nbsp;el&nbsp;=&nbsp;require(<span class="hljs-string">\'element-ui/lib/el.js\'</span>)）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.specifiers.map((ImportSpecifier)&nbsp;=&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;creatRequire(ImportSpecifier.imported.name)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;};\n};\n</pre><p><br></p><p>然后在.babelrc里边使用我们插件</p><p><br></p><pre class="ql-syntax" spellcheck="false">{\n  ...,\n  <span class="hljs-string">"plugins"</span>: [\n    [\n      <span class="hljs-string">"./myBabelPluginComponent"</span>,\n      {\n        <span class="hljs-string">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>\n      }\n    ]\n  ]\n}\n</pre><p><br></p><p>我们再次打包，看下结果</p><p><br></p><p><img src="http://qiniu.wztqy.top/a96fe8a0-e3c8-11eb-b704-e35965abd983.png"></p><p><br></p><p>打包出来的大小，与上面使用require引入的打包结果的大小是一样的，这样也证实了咱们的插件也实现了import转化成require的操作</p><p><br></p><h2><span style="color: rgb(161, 0, 0);">总结</span></h2><p><br></p><ol><li>babel-plugin-component改写了咱们的代码，但不是真实的更改，而只是在编译时做了这些事情</li><li>其原理其实就是匹配import，并替换import转换成require的形式，最终由webpack做输出，完成打包</li></ol><p><br></p><p><span style="color: rgb(230, 0, 0);">到这里就结束啦，辛苦客官捧场，小的会越来越好!!!</span></p>',
          author: '魏泽',
          hot: 2,
          putShelves: true,
          creatTime: '2021-07-13 18:00:40',
          updateTime: '2021-07-14 22:54:59'
        },
        {
          id: 16,
          title: '一百行不到webpack，你不想了解下？',
          section:
            '身为一个前端，哪怕知道webpack的存在，知道入门用法，但不知道其最基础的打包原理，我觉得有损一个前段开发的身份，接下来我将用一百行不到的代码，带你手写一个webpakc的脚本出来。',
          editorText:
            '<h2><span style="color: rgb(171, 25, 66);">究竟是啥：</span></h2><p><br></p><p><span style="color: rgb(0, 0, 0);">其实这个问题在&nbsp;</span><code style="color: rgb(161, 0, 0); background-color: rgb(248, 248, 248);">webpack</code><span style="color: rgb(161, 0, 0);">&nbsp;</span><span style="color: rgb(0, 0, 0);">官网的第一段就给出了明确的定义：</span></p><p><span style="color: rgb(0, 0, 0);">webpack 的核心是用于现代 JavaScript 应用程序的</span><strong style="color: rgb(0, 0, 0);">静态模块打包器</strong><span style="color: rgb(0, 0, 0);">。当 webpack 处理您的应用程序时，它会在内部构建一个</span><strong style="color: rgb(0, 0, 0);">依赖关系图</strong><span style="color: rgb(0, 0, 0);">，该图映射您项目所需的每个模块并</span><strong style="color: rgb(0, 0, 0);">生成一个或多个包</strong><span style="color: rgb(0, 0, 0);">。</span></p><p><br></p><p><br></p><h2><span style="color: rgb(171, 25, 66);">要干什么：</span></h2><p><br></p><p><span style="color: rgb(0, 0, 0);">可以看到，</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">node.js</code><span style="color: rgb(0, 0, 0);">&nbsp;生态中积累了大量的&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">JavaScript</code><span style="color: rgb(0, 0, 0);">&nbsp;写的代码，却因为&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">node.js</code><span style="color: rgb(0, 0, 0);">&nbsp;端遵循的&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">CommonJS</code><span style="color: rgb(0, 0, 0);">&nbsp;模块化规范与浏览器端格格不入，导致代码无法得到复用，这是一个巨大的损失。于是&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code><span style="color: rgb(0, 0, 0);">&nbsp;要做的就是将这些模块打包成可以在浏览器端使用&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">&lt;script&gt;</code><span style="color: rgb(0, 0, 0);">&nbsp;标签加载并运行的</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">JavaScript</code><span style="color: rgb(0, 0, 0);">&nbsp;文件。</span></p><p><br></p><h2><span style="color: rgb(171, 25, 66);">怎么干的：</span></h2><p><br></p><p>既然浏览器端没有&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">CommonJS</code>&nbsp;规范，那就实现一个好了。从&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>&nbsp;打包出的产物，我们能看出思路。</p><p><br></p><p>新建三个文件观察其打包产物：</p><p><br></p><p><span style="color: rgb(0, 0, 0);">src/index.js</span></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-variable">console.log</span>(<span class="hljs-string">"入口开始"</span>)\n<span class="hljs-variable">const</span> <span class="hljs-variable">printA</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">"./printA"</span>)</span>\n﻿<span class="hljs-function"><span class="hljs-title">printA</span>()</span>\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">src/</span>printA<span style="color: rgb(0, 0, 0);">.js</span></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-variable">const</span>&nbsp;<span class="hljs-variable">printB</span>&nbsp;=&nbsp;<span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">"./printB"</span>)</span>\n<span class="hljs-variable">module.exports</span>&nbsp;=&nbsp;<span class="hljs-variable">function</span>&nbsp;<span class="hljs-function"><span class="hljs-title">printA</span>()&nbsp;{\n&nbsp;&nbsp;<span class="hljs-variable">console.log</span>(<span class="hljs-string">"module&nbsp;a!"</span>)</span>\n&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-title">printB</span>()</span>\n}\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">src/</span>printB<span style="color: rgb(0, 0, 0);">.js</span></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-built_in">module</span>.exports&nbsp;=&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">printB</span>()&nbsp;</span>{\n&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"module&nbsp;b!"</span>)\n}\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">执行&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">npx webpack --mode development</code><span style="color: rgb(0, 0, 0);">&nbsp;打包产出&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">dist/index.js</code><span style="color: rgb(0, 0, 0);">&nbsp;文件</span></p><p><br></p><p><img src="http://qiniu.wztqy.top/98c948b0-dfcd-11eb-b704-e35965abd983.png"></p><p><br></p><p>上图中，使用了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>&nbsp;打包 3 个简单的 js 文件&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">index.js</code>/<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>/<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">b.js</code>, 其中&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">index.js</code>&nbsp;中依赖了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>, 而&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>&nbsp;中又依赖了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">b.js</code>, 形成一个完整依赖关系。</p><p><br></p><p>那么，<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>&nbsp;又是如何知道文件之间的依赖关系的呢，如何收集被依赖的文件保证不遗漏呢？</p><p><br></p><p><code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">webpack</code><span style="color: rgb(0, 0, 0);">&nbsp;会从配置的</span><strong style="color: rgb(0, 0, 0);">入口开始，递归的构建一个应用程序所需要的模块的依赖树</strong><span style="color: rgb(0, 0, 0);">。我们知道，</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">CommonJS</code><span style="color: rgb(0, 0, 0);">&nbsp;规范里，依赖某一个文件时，只需要使用&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code><span style="color: rgb(0, 0, 0);">&nbsp;关键字将其引入即可，那么只要我们遇到</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code><span style="color: rgb(0, 0, 0);">关键字，就去解析这个依赖，而这个依赖中可能又使用了&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code><span style="color: rgb(0, 0, 0);">&nbsp;关键字继续引用另一个依赖，于是，就可以递归的根据&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code><span style="color: rgb(0, 0, 0);">&nbsp;关键字找到所有的被依赖的文件，从而完成依赖树的构建了。</span></p><p><br></p><p>可以看到上图最终输出里，三个文件被以键值对的形式保存到&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_modules__</code>&nbsp;对象上, 对象的&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">key</code>&nbsp;为模块路径名，<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">value</code>&nbsp;为一个被包装过的模块函数。函数拥有&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">module</code>,&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">module.exports</code>,&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>&nbsp;三个参数。这使得每个模块都拥有使用&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">module.exports</code>&nbsp;导出本模块和使用&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>&nbsp;引入其他模块的能力，同时保证了每个模块都处于一个隔离的函数作用域范围。</p><p><br></p><p>为什么&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>要修改<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code>关键字和<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code>的路径？我们知道<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code>是<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">node</code>环境自带的环境变量，可以直接使用，而在其他环境则没有这样一个变量，于是需要<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>提供这样的能力。只要提供了相似的能力，变量名叫&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">require</code>还是&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>其实无所谓。至于重写路径，当然是因为在<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">node</code>端系统会根据文件的路径加载，而在&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>打包的文件中，使用原路径行不通，于是需要将路径重写为&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_modules__</code>&nbsp;的键，从而找到相应模块。</p><p><br></p><p>而下面的&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>函数与&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_module_cache__</code>&nbsp;对象则完成了模块加载的职责。使用&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>&nbsp;函数加载完成的模块被缓存到&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_module_cache__</code>&nbsp;对象上，以便下次如果有其他模块依赖此模块时，<strong>不需要重新运行模块的包装函数，减少执行效率的消耗</strong>。同时，如果多个文件之间存在循环依赖，比如&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>&nbsp;依赖了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">b.js</code>&nbsp;文件,&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">b.js</code>&nbsp;又依赖了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>，那么在&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">b.js</code>&nbsp;使用&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">__webpack_require__</code>加载&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>&nbsp;时，会直接走进&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">if(cachedModule !== undefined)</code>&nbsp;分支然后&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">return</code>已缓存过的&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>&nbsp;的引用，不会进一步执行&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">a.js</code>&nbsp;文件加载，从而<strong>避免了循环依赖无限递归的出现</strong>。</p><p><br></p><p>不能说这个由&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>&nbsp;实现的模块加载器与&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">CommonJS</code>&nbsp;规范一毛一样，只能说八九不离十吧。这样一来，打包后的&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">JavaScript</code>&nbsp;文件可以被&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">&lt;script&gt;</code>&nbsp;标签加载且运行在浏览器端了。</p><p><br></p><h2><span style="color: rgb(171, 25, 66);">简易实现：</span></h2><p><br></p><p>了解了&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">webpack</code>&nbsp;处理后的&nbsp;<code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">JavaScript</code>&nbsp;长成什么样子，我们梳理一下思路，依葫芦画瓢手动实现一个简易的打包器，帮助理解。</p><p><br></p><p>要做的事情有这么些：</p><ol><li>读取入口文件，并收集依赖信息</li><li>递归地读取所有依赖模块，产出完整的依赖列表</li><li>将各模块内容打包成一块完整的可运行代码</li></ol><p><br></p><p>话不多说，创建一个项目，并安装所需依赖</p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-built_in">npm</span> init -y\n<span class="hljs-built_in">npm</span> i @babel/core @babel/parser @babel/traverse -D\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">其中：</span></p><ul><li><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">@babel/parser</code>&nbsp;用于解析源代码，产出 AST</li><li><code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">@babel/traverse</code>&nbsp;用于遍历 AST，找到&nbsp;<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">require</code>&nbsp;语句并修改成&nbsp;<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">_require_</code>，将引入路径改造为相对根的路径</li><li><code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">@babel/core</code>&nbsp;用于将修改后的 AST 转换成新的代码输出</li></ul><p><br></p><p><span style="color: rgb(0, 0, 0);">创建一个入口文件 myPack.js 并引入依赖</span></p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-keyword">const</span>&nbsp;fs&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n<span class="hljs-keyword">const</span>&nbsp;path&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span>&nbsp;parser&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">\'@babel/parser\'</span>)\n<span class="hljs-keyword">const</span>&nbsp;traverse&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">\'@babel/traverse\'</span>).<span class="hljs-keyword">default</span>\n<span class="hljs-keyword">const</span>&nbsp;babel&nbsp;=&nbsp;<span class="hljs-built_in">require</span>(<span class="hljs-string">\'@babel/core\'</span>)\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">紧接着，我们需要对某一个模块进行解析，并产出其模块信息，包括：模块路径、模块依赖、模块转换后代码</span></p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-comment">//&nbsp;保存根路径，所有模块根据根路径产出相对路径</span>\n<span class="hljs-keyword">let</span>&nbsp;root&nbsp;=&nbsp;process.cwd();\n\n\n<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">readModuleInfo</span>(<span class="hljs-params">filePath</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;准备好相对路径作为&nbsp;module&nbsp;的&nbsp;key</span>\n&nbsp;&nbsp;filePath&nbsp;=\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"./"</span>&nbsp;+&nbsp;path.relative(root,&nbsp;path.resolve(filePath)).replace(<span class="hljs-regexp">/\\\\+/g</span>,&nbsp;<span class="hljs-string">"/"</span>);\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;读取源码</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;content&nbsp;=&nbsp;fs.readFileSync(filePath,&nbsp;<span class="hljs-string">"utf-8"</span>);\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;转换出&nbsp;AST</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;ast&nbsp;=&nbsp;parser.parse(content);\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;遍历模块&nbsp;AST，将依赖收集到&nbsp;deps&nbsp;数组中</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;deps&nbsp;=&nbsp;[];\n&nbsp;&nbsp;traverse(ast,&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">CallExpression</span>:&nbsp;<span class="hljs-function">(<span class="hljs-params">{&nbsp;node&nbsp;}</span>)&nbsp;=&gt;</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果是&nbsp;require&nbsp;语句，则收集依赖</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(node.callee.name&nbsp;===&nbsp;<span class="hljs-string">"require"</span>)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;改造&nbsp;require&nbsp;关键字</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.callee.name&nbsp;=&nbsp;<span class="hljs-string">"_require_"</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;moduleName&nbsp;=&nbsp;node.arguments[<span class="hljs-number">0</span>].value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moduleName&nbsp;+=&nbsp;path.extname(moduleName)&nbsp;?&nbsp;<span class="hljs-string">""</span>&nbsp;:&nbsp;<span class="hljs-string">".js"</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moduleName&nbsp;=&nbsp;path.join(path.dirname(filePath),&nbsp;moduleName);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moduleName&nbsp;=\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"./"</span>&nbsp;+&nbsp;path.relative(root,&nbsp;moduleName).replace(<span class="hljs-regexp">/\\\\+/g</span>,&nbsp;<span class="hljs-string">"/"</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps.push(moduleName);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;改造依赖的路径</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.arguments[<span class="hljs-number">0</span>].value&nbsp;=&nbsp;moduleName;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;});\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;编译回代码</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;{&nbsp;code&nbsp;}&nbsp;=&nbsp;babel.transformFromAstSync(ast);\n&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;filePath,\n&nbsp;&nbsp;&nbsp;&nbsp;deps,\n&nbsp;&nbsp;&nbsp;&nbsp;code,\n&nbsp;&nbsp;};\n}\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">接下来，我们从入口出发递归地找到所有被依赖的模块，并构建成依赖树</span></p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">buildDependencyGraph</span>(<span class="hljs-params">entry</span>)&nbsp;</span>{\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;获取入口模块信息</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;entryInfo&nbsp;=&nbsp;readModuleInfo(entry);\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;项目依赖树</span>\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;graphArr&nbsp;=&nbsp;[];\n&nbsp;&nbsp;graphArr.push(entryInfo);\n&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;从入口模块触发，递归地找每个模块的依赖，并将每个模块信息保存到&nbsp;graphArr</span>\n&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-built_in">module</span>&nbsp;<span class="hljs-keyword">of</span>&nbsp;graphArr)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">module</span>.deps.forEach(<span class="hljs-function">(<span class="hljs-params">depPath</span>)&nbsp;=&gt;</span>&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;moduleInfo&nbsp;=&nbsp;readModuleInfo(path.resolve(depPath));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graphArr.push(moduleInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;}\n&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;graphArr;\n}\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">经过上面一步，我们已经得到依赖树能够描述整个应用的依赖情况，最后我们只需要按照目标格式进行打包输出即可</span></p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-keyword">function</span>&nbsp;pack(graph,&nbsp;entry)&nbsp;{\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;moduleArr&nbsp;=&nbsp;graph.<span class="hljs-keyword">map</span>((<span class="hljs-built_in">module</span>)&nbsp;=&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<span class="hljs-string">"${module.filePath}"</span>:&nbsp;<span class="hljs-keyword">function</span>(<span class="hljs-built_in">module</span>,&nbsp;<span class="hljs-built_in">exports</span>,&nbsp;_require_)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">eval</span>(<span class="hljs-string">\\``</span>&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">module</span>.code&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<span class="hljs-string">\\`)</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}`\n&nbsp;&nbsp;&nbsp;&nbsp;);\n&nbsp;&nbsp;});\n&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;output&nbsp;=&nbsp;`;(()&nbsp;=&gt;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;modules&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${moduleArr.join(<span class="hljs-string">",\\n"</span>)}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;modules_cache&nbsp;=&nbsp;{}\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;_require_&nbsp;=&nbsp;<span class="hljs-keyword">function</span>(moduleId)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(modules_cache[moduleId])&nbsp;<span class="hljs-keyword">return</span>&nbsp;modules_cache[moduleId].<span class="hljs-built_in">exports</span>\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;<span class="hljs-built_in">module</span>&nbsp;=&nbsp;modules_cache[moduleId]&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exports:&nbsp;{}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modules[moduleId](<span class="hljs-built_in">module</span>,&nbsp;<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span>,&nbsp;_require_)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span>\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;_require_(<span class="hljs-string">\'${entry}\'</span>)\n&nbsp;&nbsp;})()`;\n&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;output;\n}\n</pre><p><br></p><p>直接使用字符串模板拼接成类&nbsp;<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">CommonJS</code>&nbsp;规范的模板，自动加载入口模块，并使用 IIFE 将代码包装，保证代码模块不会影响到全局作用域。</p><p><br></p><p>最后，编写一个入口函数&nbsp;<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">main</code>&nbsp;用以启动打包过程</p><p><br></p><pre class="ql-syntax" spellcheck="false">function&nbsp;main(entry&nbsp;=&nbsp;<span class="hljs-string">\'./src/index.js\'</span>,&nbsp;output&nbsp;=&nbsp;<span class="hljs-string">\'./dist.js\'</span>)&nbsp;{\n&nbsp;&nbsp;fs.writeFileSync(output,&nbsp;pack(buildDependencyGraph(entry),&nbsp;entry))\n}\n\nmain()\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">执行并验证结果</span></p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-keyword">node</span>&nbsp;<span class="hljs-title">myPack</span>.js\n</pre><p><br></p><p><span style="color: rgb(0, 0, 0);">至此，我们使用了总共不到 90 行代码（包含注释），完成了一个极简的模块打包工具。虽然没有涉及任何&nbsp;</span><code style="color: rgb(233, 105, 0); background-color: rgb(248, 248, 248);">Webpack</code><span style="color: rgb(0, 0, 0);">&nbsp;源码， 但我们从打包器的设计原理入手，走过了打包工具的核心步骤，简易却不失完整。</span></p><p><br></p><p><br></p><h2><span style="color: rgb(171, 25, 66);">总结：</span></h2><p><br></p><p>本文从&nbsp;<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">webpack</code>&nbsp;的设计理念和最终实现出发，梳理了其作为一个打包工具的核心能力，并使用一个简易版本实现帮助更直观的理解其本质。总的来说，<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">webpack</code>&nbsp;作为打包工具无非是<strong>从应用入口出发，递归的找到所有依赖模块，并将他们解析输出成一个具备类 CommonJS 模块化规范的模块加载能力的 JavaScript 文件</strong>。</p><p><br></p><p>因其优秀的设计，在实际生产环节中，<code style="background-color: rgb(248, 248, 248); color: rgb(233, 105, 0);">webapck</code>&nbsp;还能扩展出诸多强大的功能。然而其本质仍是模块打包器。不论是什么样的新特性或新能力，只要我们把握住打包工具的核心思想，任何问题终将迎刃而解。</p><p><br></p><p><span style="color: rgb(230, 0, 0);">到这里就结束啦，辛苦客官捧场，小的会越来越好!!!</span></p>',
          author: '魏泽',
          hot: 3,
          putShelves: true,
          creatTime: '2021-07-08 16:59:14',
          updateTime: '2021-07-14 11:22:08'
        },
        {
          id: 14,
          title: '如果在windows系统上安装mysql',
          section: '如果在windows系统上安装mysql',
          editorText:
            '<h2>step1：下载mysql zip压缩包</h2><p><br></p><p>进入：<a href="https://downloads.mysql.com/archives/community/" rel="noopener noreferrer" target="_blank">https://downloads.mysql.com/archives/community/</a></p><p><br></p><p><img src="http://qiniu.wztqy.top/b8197810-d493-11eb-b704-e35965abd983.png"></p><p><br></p><p><br></p><p><br></p><p><br></p><h2>step2：初始化数据库</h2><p><br></p><p>解压mysql;</p><p>进入到mysql/bin目录下执行：</p><p><br></p><pre class="ql-syntax" spellcheck="false"><span class="hljs-regexp">//</span>初始化根目录data目录\nmysqld &nbsp;--initialize-insecure\n<span class="hljs-regexp">//</span>初始化数据，显示Service successfully installed.完成\nmysqld install mysql\n<span class="hljs-regexp">//</span>﻿启动mysql服务\nnet start mysql \n<span class="hljs-regexp">//</span>登录mysql\nmysql -uroot\n<span class="hljs-regexp">//</span>切换数据库\nuse mysql;\n<span class="hljs-regexp">//</span>设置root用户的密码为<span class="hljs-number">225514</span>，这个密码自己随意定义\nalter user <span class="hljs-string">\'root\'</span>@localhost identified by <span class="hljs-string">\'225514\'</span>;\n<span class="hljs-regexp">//</span>刷新权限\nflush privileges; \n<span class="hljs-regexp">//</span>退出\nquit\n<span class="hljs-regexp">//</span>测试密码（可选操作），输入上边自己设置的密码即可，可以进去后quit退出\nmysql -uroot -p\n</pre><p><br></p><p>这样子你的数据库就安装好了，但你可能还在为你的数据库账号密码发愁，其实上面都配置好了</p><p>\t账号：root</p><p>\t密码：225514</p><p><br></p><p><span style="color: rgb(230, 0, 0);">注意事项：</span></p><p><br></p><p>一，在使用<span style="color: rgb(51, 51, 51);">Navicat 连接MySQL数据库时出现的错误：2059 - authentication plugin \'caching_sha2_password\' 的解决方法：</span></p><p>进入mysql的bin目录下执行</p><pre class="ql-syntax" spellcheck="false">//进入mysql\nmysql -uroot -p //输入密码进入\t\t\n//依次执行\n<span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">\'default_authentication_plugin\'</span>;\n<span class="hljs-keyword">select</span> host,<span class="hljs-keyword">user</span>,plugin <span class="hljs-keyword">from</span> mysql.<span class="hljs-keyword">user</span>;\n<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">\'root\'</span>@<span class="hljs-string">\'localhost\'</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">\'225514\'</span>; \nquit\n</pre><p><br></p><p><span style="color: rgb(230, 0, 0);">到这里就结束啦，辛苦客官捧场，小的会越来越好!!!</span></p><p><br></p>',
          author: '魏泽',
          hot: 2,
          putShelves: false,
          creatTime: '2021-06-24 10:14:32',
          updateTime: '2021-06-24 19:15:37'
        }
      ],
      columns: [
        {
          title: '标题',
          dataIndex: 'title',
          width: 300
        },
        {
          title: '描述',
          dataIndex: 'section',
          width: 600
        },
        {
          title: '热度',
          dataIndex: 'hot',
          width: 100
        },
        {
          title: '已上架',
          dataIndex: 'putShelves',
          width: 100,
          render: (text) => {
            return text ? '已上架' : '未上架';
          }
        },
        {
          title: '创建时间',
          dataIndex: 'creatTime',
          width: 150
        },
        {
          title: '操作',
          dataIndex: 'operation',
          width: 180,
          render: () => {
            return (
              <div className="group-button">
                <Button type="primary">编辑</Button>
                <Button type="primary" danger>
                  删除
                </Button>
              </div>
            );
          }
        }
      ]
    };
  }

  render() {
    const { dataSource, columns } = this.state;
    return <Table rowKey="id" dataSource={dataSource} columns={columns} />;
  }
}

export default index;
